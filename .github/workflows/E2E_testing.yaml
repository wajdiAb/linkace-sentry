name: Deploy to EC2

on:
  pull_request:
    branches:
      - main  # or your deployment branch
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to test against'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

permissions:
  contents: read
  pages: write
  id-token: write



jobs:
  deploy-to-ec2:
    runs-on: ubuntu-latest

    #outputs:
      #api_token: ${{ steps.deploy.outputs.api_token }}

    steps:
    - name: Get code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install test dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio httpx mock allure-pytest
        pip install docker paramiko boto3


    - name: Deploy to EC2
      id: deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # Update and install Docker if not already installed
          sudo apt-get update -y
          sudo apt-get install -y docker.io docker-compose-plugin git jq
          sudo usermod -aG docker ubuntu || true

          
          # Clean up ALL existing containers first
          echo "ðŸ§¹ Cleaning up existing containers..."
          docker stop $(docker ps -q) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true
          docker system prune -af || true

          
          # Clean up directories completely and start fresh
          cd /home/ubuntu
          rm -rf LinkAce2 linkace-sentry
          mkdir -p LinkAce2
          cd LinkAce2
        

           # Clone the complete repository for source code
          echo "ðŸ“¥ Cloning linkace-sentry repository..."
          git clone https://github.com/wajdiAb/linkace-sentry.git
          
          

          # starting linkace application
          cd ~/LinkAce2
          touch database.sqlite
          chmod 0766 database.sqlite
          docker run -d --name linkace_app_1 -p "8080:80" -v "./database.sqlite:/app/database/database.sqlite" linkace/linkace
          
          sleep 10
          docker exec -i linkace_app_1 php artisan migrate --force
          docker exec -i linkace_app_1 php artisan setup:complete
          docker exec -i linkace_app_1 php artisan registeruser --admin <<EOF
          ${{ secrets.LINKACE_NAME }}
          ${{ secrets.LINKACE_EMAIL }}
          ${{ secrets.LINKACE_PASSWORD }}
          EOF

          echo "ðŸ”‘ Generating API token..."
          PHP_SNIPPET='
          require "/app/vendor/autoload.php";
          $app = require "/app/bootstrap/app.php";
          $kernel = $app->make(Illuminate\Contracts\Console\Kernel::class);
          $kernel->bootstrap();

          $email = getenv("LA_EMAIL");
          $user  = \App\Models\User::where("email", $email)->first();
          if (!$user) { fwrite(STDERR, "ERROR: user not found for $email\n"); exit(1); }
          if (!method_exists($user, "createToken")) {
              fwrite(STDERR, "ERROR: createToken() not available. Create a token in the UI instead.\n");
              exit(2);
          }
          $token = $user->createToken("LinkAce-Sentry-Auto-Token");
          echo "TOKEN=".$token->plainTextToken."\n";
          ';

          API_TOKEN=$(docker exec -e LA_EMAIL="${{ secrets.LINKACE_EMAIL }}" linkace_app_1 \
            php -r "$PHP_SNIPPET" 2>&1 | sed -n 's/^TOKEN=//p' | tail -n1)

          if [[ -z "$API_TOKEN" || "$API_TOKEN" != *"|"* ]]; then
            echo "âŒ Failed to generate API token automatically"
            exit 1
          fi

          echo "âœ… API token generated. First 20 chars: ${API_TOKEN:0:20}..."
          #   API_TOKEN=$API_TOKEN
          
          # Save API token to a file that we can read back
          echo "$API_TOKEN" > /tmp/linkace_api_token.txt
          chmod 600 /tmp/linkace_api_token.txt

          echo "ðŸ“š Adding test bookmarks..."

          curl -sS -X POST "http://localhost:8080/api/v2/links" \
            -H "Authorization: Bearer $API_TOKEN" -H "Accept: application/json" -H "Content-Type: application/json" \
            -d '{"url":"https://httpbin.org/status/200","title":"Test Working Link","description":"This link should work fine"}' \
            || echo "âš ï¸ Failed to add working test link"

          curl -sS -X POST "http://localhost:8080/api/v2/links" \
            -H "Authorization: Bearer $API_TOKEN" -H "Accept: application/json" -H "Content-Type: application/json" \
            -d '{"url":"https://httpbin.org/status/404","title":"Test Dead Link","description":"This link should be detected as dead"}' \
            || echo "âš ï¸ Failed to add dead test link"

          curl -sS -X POST "http://localhost:8080/api/v2/links" \
            -H "Authorization: Bearer $API_TOKEN" -H "Accept: application/json" -H "Content-Type: application/json" \
            -d '{"url":"https://httpbin.org/redirect/3","title":"Test Redirect Link","description":"This link should be detected as redirected"}' \
            || echo "âš ï¸ Failed to add redirect test link"

          curl -sS -X POST "http://localhost:8080/api/v2/links" \
            -H "Authorization: Bearer $API_TOKEN" -H "Accept: application/json" -H "Content-Type: application/json" \
            -d '{"url":"https://httpbin.org/delay/2","title":"Test Slow Link","description":"This link responds slowly but should work"}' \
            || echo "âš ï¸ Failed to add slow test link"

          echo "ðŸ” Verifying bookmarks..."
          RESP=$(curl -sS -L "http://localhost:8080/api/v2/links" \
            -H "Authorization: Bearer $API_TOKEN" \
            -H "Accept: application/json")

          TOTAL=$(echo "$RESP" | jq -r '(.meta.total // (.data | length) // 0)')
          echo "ðŸ“Š Total bookmarks in LinkAce: $TOTAL"
          
          echo "api_token=$API_TOKEN" >> $GITHUB_OUTPUT

          # Create/overwrite .env for compose
          cat > /home/ubuntu/LinkAce2/.env << EOF
          LINKACE_BASE_URL=http://host.docker.internal:8080
          LINKACE_API_TOKEN=$API_TOKEN
          ADMIN_TOKEN=$API_TOKEN
          AWS_SNS_TOPIC_ARN=${{ secrets.AWS_SNS_TOPIC_ARN }}
          AWS_REGION=eu-west-1
          CHECK_INTERVAL_MIN=30
          CONCURRENCY=10
          TAG_DEAD_NAME=dead
          TAG_REDIRECTED_NAME=redirected
          UPDATE_MODE=tags
          EOF

          # Copy the environment file to the cloned repo
          cp .env linkace-sentry/
          cd linkace-sentry
          rm -f docker-compose.yml
          
          cat > docker-compose.yml << 'EOL'
          services:
            linkace-sentry:
              build:
                context: .
                dockerfile: Dockerfile
              image: wajdiab/linkace-sentry:0.0.2
              container_name: linkace-sentry
              volumes:
                - ./src:/app/src
              user: "1000:1000"
              env_file:
                - .env
              environment:
                AWS_REGION: ${AWS_REGION}
                AWS_SNS_TOPIC_ARN: ${AWS_SNS_TOPIC_ARN}

              extra_hosts:
                - "host.docker.internal:host-gateway"
              restart: unless-stopped
          EOL

          # Build and start LinkAce Sentry (this includes source code)
          echo "ðŸ” Building and starting LinkAce Sentry..."
          
          # Make sure we're in the right directory with source code
          ls -la src/  # Verify source code exists
          
          # Build the image locally to include source code
          docker build -t linkace-sentry-local .
          
          # Update docker-compose to use local build
          sed -i 's/image: wajdiab\/linkace-sentry:0\.0\.2/image: linkace-sentry-local/' docker-compose.yml
          
          # Start the service
          docker compose up -d linkace-sentry
          
          # Verify the deployment
          docker ps
          docker logs linkace-sentry --tail 100

    # ALTERNATIVE: Use a different SSH action that can capture output
    - name: Get API Token from Server
      id: get-token
      run: |
        # Use SSH to get the token and capture it
        API_TOKEN=$(ssh -o StrictHostKeyChecking=no -i <(echo "${{ secrets.EC2_SSH_KEY }}") ubuntu@${{ secrets.EC2_HOST }} "cat /tmp/linkace_api_token.txt 2>/dev/null || echo 'TOKEN_NOT_FOUND'")
        
        if [[ "$API_TOKEN" == "TOKEN_NOT_FOUND" || -z "$API_TOKEN" ]]; then
          echo "âŒ Failed to retrieve API token from server"
          exit 1
        fi
        
        echo "âœ… Successfully retrieved API token"
        echo "api_token=$API_TOKEN" >> $GITHUB_OUTPUT

    # Update the job output to use the correct step
    outputs:
      api_token: ${{ steps.get-token.outputs.api_token }}

  API-test:
    runs-on: ubuntu-latest

    needs: deploy-to-ec2

    steps:
    - name: Get code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        repository: wajdiAb/LinkAce-project
        token: ${{ secrets.API_TESTING_GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install test dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio httpx mock allure-pytest selenium webdriver-manager python-dotenv
        pip install docker paramiko boto3

    - name: Run API tests
      env:
        BASE_URL: ${{ secrets.EC2_HOST }}
        # LINKACE_API_TOKEN: ${{ needs.deploy-to-ec2.outputs.api_token }}
        LINKACE_API_TOKEN: $API_TOKEN
      run: |
        pytest API_tests/* -q --maxfail=1 --disable-warnings --tb=short --junitxml=api_results.xml --alluredir=./allure-results || true
        allure generate ./allure-results --clean -o ./allure-report || true

    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      with:
        name: allure-results-api
        path: ./allure-results



  UI-test:
    runs-on: ubuntu-latest

    needs: deploy-to-ec2

    steps:
    - name: Get code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        repository: wajdiAb/LinkAce-UI-testing
        token: ${{ secrets.API_TESTING_GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest requests python-dotenv

    - name: Install Chrome and ChromeDriver
      run: |
        sudo apt-get update
        sudo apt-get install -y google-chrome-stable

    - name: Run Selenium tests
      env:
        HEADLESS: true
        LINKACE_URL: http://${{ secrets.EC2_HOST }}:8080
        LINKACE_EMAIL: ${{ secrets.LINKACE_EMAIL }}
        LINKACE_PASSWORD: ${{ secrets.LINKACE_PASSWORD }}
      run: |
        pytest UI_tests/* -s -v --tb=short --junitxml=ui_results.xml || true
        allure generate ./allure-results --clean -o ./allure-report || true

    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      with:
        name: allure-results-ui
        path: ./allure-results

# Publish Allure report 
  publish-allure:
    runs-on: ubuntu-22.04
    needs: [API-test, UI-test]
    if: always()
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    env:
      IMAGE_TAG: LinkAce.latest
      LinkAce_URL: http://${{ secrets.EC2_HOST }}:8080/
      TEST_ENVIRONMENT: ${{ github.event_name == 'pull_request' && format('PR-{0}', github.event.pull_request.number) || format('{0}', github.event.inputs.environment || 'Manual') }}
    steps:
      - name: Download API Allure results
        uses: actions/download-artifact@v4
        with:
          name: allure-results-api
          path: allure-download/api
        continue-on-error: true

      - name: Download UI Allure results
        uses: actions/download-artifact@v4
        with:
          name: allure-results-ui
          path: allure-download/ui
        continue-on-error: true

      - name: Merge results and add environment.properties
        run: |
          mkdir -p allure-results
          if [ -d "allure-download/api" ]; then
            cp -r allure-download/api/* allure-results/ 2>/dev/null || true
          fi
          if [ -d "allure-download/ui" ]; then
            cp -r allure-download/ui/* allure-results/ 2>/dev/null || true
          fi
          cat > allure-results/environment.properties <<EOF
          Environment=${{ env.TEST_ENVIRONMENT }}
          Image.Tag=${{ env.IMAGE_TAG }}
          LinkAce.URL=${{ env.LinkAce_URL }}
          GitHub.Run.ID=${{ github.run_id }}
          GitHub.Actor=${{ github.actor }}
          Workflow.Trigger=${{ github.event_name }}
          Branch=${{ github.head_ref || github.ref_name }}
          Commit.SHA=${{ github.sha }}
          Repository=${{ github.repository }}
          Timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          EOF

      - name: Setup Allure
        run: |
          npm install -g allure-commandline
          allure --version

      - name: Generate Allure report
        run: |
          allure generate allure-results --clean -o _site
          touch _site/.nojekyll

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: _site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4